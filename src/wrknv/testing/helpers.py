#
# SPDX-FileCopyrightText: Copyright (c) 2025 provide.io llc. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#

"""Test helpers for using wrknv-managed workenv directories instead of .venv.

This ensures tests use the proper workenv/package_os_arch pattern
that wrknv is designed to manage."""

from __future__ import annotations

from collections.abc import Iterator
import contextlib
import os
from pathlib import Path
import platform
import sys
from typing import Any

from provide.foundation import logger
from provide.foundation.process import CompletedProcess, run


def get_workenv_dir(package_name: str | None = None) -> Path:
    """
    Get the proper workenv directory path for the current platform.

    Args:
        package_name: Optional package name. If not provided, uses the
                     current directory name.

    Returns:
        Path to the workenv directory (e.g., workenv/package_darwin_arm64)
    """
    if package_name is None:
        package_name = Path.cwd().name

    # Get platform info
    system = platform.system().lower()
    machine = platform.machine().lower()

    # Normalize architecture names
    if machine in ["x86_64", "amd64"]:
        arch = "amd64"
    elif machine in ["arm64", "aarch64"]:
        arch = "arm64"
    else:
        arch = machine

    # Build directory name: workenv/package_os_arch
    workenv_dir = Path.cwd() / "workenv" / f"{package_name}_{system}_{arch}"
    return workenv_dir


def activate_workenv(package_name: str | None = None) -> dict[str, str]:
    """
    Get environment variables for activating a wrknv-managed workenv.

    Args:
        package_name: Optional package name.

    Returns:
        Dictionary of environment variables to set.
    """
    workenv_dir = get_workenv_dir(package_name)

    if not workenv_dir.exists():
        raise RuntimeError(
            f"Workenv directory not found: {workenv_dir}\nRun 'wrknv setup' or 'source env.sh' to create it."
        )

    # Build environment variables
    env = os.environ.copy()

    # Set VIRTUAL_ENV
    env["VIRTUAL_ENV"] = str(workenv_dir)

    # Update PATH to include workenv bin directory
    bin_dir = workenv_dir / "bin"
    if bin_dir.exists():
        env["PATH"] = f"{bin_dir}:{env.get('PATH', '')}"

    # Set PYTHONPATH to include site-packages
    site_packages = (
        workenv_dir / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}" / "site-packages"
    )
    if site_packages.exists():
        env["PYTHONPATH"] = f"{site_packages}:{env.get('PYTHONPATH', '')}"

    # Unset PYTHONHOME if set (can interfere with virtual env)
    env.pop("PYTHONHOME", None)

    return env


@contextlib.contextmanager
def workenv_context(package_name: str | None = None) -> Iterator[None]:
    """
    Context manager for running code with workenv activated.

    Usage:
        with workenv_context('pyvider'):
            # Code here runs with workenv activated
            import pyvider
    """
    old_env = os.environ.copy()
    try:
        new_env = activate_workenv(package_name)
        os.environ.update(new_env)
        yield
    finally:
        os.environ.clear()
        os.environ.update(old_env)


class WorkenvTestRunner:
    """
    Test runner that uses wrknv-managed workenv directories.

    This should be used instead of creating .venv directories.
    """

    def __init__(self, package_name: str | None = None) -> None:
        """
        Initialize the test runner.

        Args:
            package_name: Optional package name. Defaults to current directory name.
        """
        self.package_name = package_name or Path.cwd().name
        self.workenv_dir = get_workenv_dir(self.package_name)

    def setup(self, force: bool = False) -> None:
        """
        Set up the workenv by sourcing env.sh.

        The env.sh script generated by wrknv will automatically:
        - Create the workenv directory if it doesn't exist
        - Install UV if needed
        - Set up the virtual environment
        - Install all dependencies

        Args:
            force: If True, recreate the workenv even if it exists.
        """
        # Check if env.sh exists
        env_script = Path.cwd() / "env.sh"
        if not env_script.exists():
            raise RuntimeError(f"env.sh not found in {Path.cwd()}\nRun 'wrknv generate' to create it.")

        if force and self.workenv_dir.exists():
            import shutil

            logger.info("removing_workenv", path=str(self.workenv_dir))
            shutil.rmtree(self.workenv_dir)

        # Source env.sh - this will create the workenv directory automatically
        logger.info("setting_up_workenv")
        result = run(["bash", "-c", f"source {env_script} && echo 'Workenv ready at: $VIRTUAL_ENV'"])

        if result.returncode != 0:
            raise RuntimeError(f"Failed to source env.sh: {result.stderr}")

        logger.debug("workenv_setup_output", stdout=result.stdout)

    def install_deps(self, editable: bool = True, extras: str | None = None) -> None:
        """
        Install package dependencies in the workenv.

        Args:
            editable: If True, install in editable mode.
            extras: Optional extras to install (e.g., "dev,test").
        """
        env = activate_workenv(self.package_name)

        # Build install command
        cmd = [str(self.workenv_dir / "bin" / "python"), "-m", "pip", "install"]

        if editable:
            cmd.append("-e")

        # Add package path with extras if specified
        package_spec = "."
        if extras:
            package_spec = f".[{extras}]"
        cmd.append(package_spec)

        logger.info("installing_dependencies", cmd=cmd)
        run(cmd, env=env, check=True)

    def run_pytest(self, *args: str, **kwargs: Any) -> CompletedProcess:
        """
        Run pytest with the workenv activated.

        Args:
            *args: Arguments to pass to pytest.
            **kwargs: Keyword arguments for subprocess.run.

        Returns:
            CompletedProcess instance with the result.
        """
        env = activate_workenv(self.package_name)

        # Build pytest command
        pytest_cmd = [str(self.workenv_dir / "bin" / "python"), "-m", "pytest"]
        pytest_cmd.extend(args)

        logger.info("running_tests", cmd=pytest_cmd)
        return run(pytest_cmd, env=env, **kwargs)

    def run(self, cmd: list[str], **kwargs: Any) -> CompletedProcess:
        """
        Run any command with the workenv activated.

        Args:
            cmd: Command to run as a list.
            **kwargs: Keyword arguments for subprocess.run.

        Returns:
            CompletedProcess instance with the result.
        """
        env = activate_workenv(self.package_name)
        return run(cmd, env=env, **kwargs)


def pytest_with_workenv(package_name: str | None = None, *pytest_args: str) -> int:
    """
    Convenience function to run pytest with workenv activated.

    Args:
        package_name: Optional package name.
        *pytest_args: Arguments to pass to pytest.

    Returns:
        Exit code from pytest.
    """
    runner = WorkenvTestRunner(package_name)
    runner.setup()
    result = runner.run_pytest(*pytest_args, capture_output=False)
    return result.returncode


# ğŸ§°ğŸŒğŸ”š
