#
# SPDX-FileCopyrightText: Copyright (c) 2025 provide.io llc. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#

"""Gitignore File Builder
======================
Constructs gitignore files with proper formatting and sections."""

from __future__ import annotations

from pathlib import Path

from provide.foundation import logger
from provide.foundation.time import provide_now

# Pattern dictionaries for ecosystem-specific sections
WRKNV_PATTERNS: dict[str, list[str]] = {
    "Work environment directories": [
        "workenv/",
        "wrknv_*/",
    ],
    "wrknv configuration and cache": [
        ".wrknv/",
        "*.wrknv.bak",
    ],
    "Container volumes": [
        ".wrknv_*/",
    ],
}

PROVIDE_PATTERNS: dict[str, list[str]] = {
    "Generated outputs and artifacts": [
        ".provide/output/",
        ".provide/shared/",
        ".provide/logs/",
        ".provide/cache/",
    ],
    "Log files": [
        "*.log",
        "*.log.*",
        "logs/",
    ],
    "Local/temporary files": [
        "*.local",
        "*.local.*",
        ".*.local",
        "*.bak",
        "*.tmp",
    ],
}


class GitignoreBuilder:
    """Builds gitignore files with proper sections and formatting."""

    def __init__(self) -> None:
        """Initialize the builder."""
        self.sections: list[tuple[str, str]] = []
        self.custom_rules: list[str] = []
        logger.debug("GitignoreBuilder initialized")

    def add_header(self, project_name: str | None = None) -> None:
        """
        Add a header section to the gitignore.

        Args:
            project_name: Optional project name for the header
        """
        header_lines = [
            "# ========================",
            "# Generated by wrknv",
            f"# Date: {provide_now().strftime('%Y-%m-%d %H:%M:%S')}",
        ]

        if project_name:
            header_lines.append(f"# Project: {project_name}")

        header_lines.extend(
            [
                "# ========================",
                "",
                "# This file is auto-generated. Custom rules should be added",
                "# in the 'Custom Rules' section at the bottom to preserve them",
                "# during regeneration.",
                "",
            ]
        )

        self.sections.insert(0, ("header", "\n".join(header_lines)))
        logger.debug(f"Added header for project: {project_name}")

    def add_template_section(self, name: str, content: str) -> None:
        """
        Add a template section.

        Args:
            name: Template name
            content: Template content
        """
        if not content:
            logger.warning(f"Empty content for template: {name}")
            return

        section_header = f"\n# === {name} ===\n"
        section_content = content.strip()

        self.sections.append((name, section_header + section_content))
        logger.debug(f"Added template section: {name}")

    def _build_section_content(self, section_name: str, patterns: dict[str, list[str]]) -> str:
        """Build section content from pattern dictionary.

        Args:
            section_name: Name of the section (e.g., "wrknv", "Provide Ecosystem")
            patterns: Dictionary mapping category names to lists of patterns

        Returns:
            Formatted section content string
        """
        lines = ["", f"# === {section_name} ==="]
        for category, items in patterns.items():
            lines.append(f"# {category}")
            lines.extend(items)
            lines.append("")
        return "\n".join(lines)

    def add_wrknv_section(self) -> None:
        """Add wrknv-specific ignore patterns."""
        content = self._build_section_content("wrknv", WRKNV_PATTERNS)
        self.sections.append(("wrknv", content))
        logger.debug("Added wrknv-specific patterns")

    def add_provide_section(self) -> None:
        """Add provide ecosystem ignore patterns."""
        content = self._build_section_content("Provide Ecosystem", PROVIDE_PATTERNS)
        self.sections.append(("provide", content))
        logger.debug("Added provide ecosystem patterns")

    def add_custom_rules(self, rules: list[str]) -> None:
        """
        Add custom rules.

        Args:
            rules: List of custom ignore patterns
        """
        if not rules:
            return

        self.custom_rules.extend(rules)
        logger.debug(f"Added {len(rules)} custom rules")

    def build(self, merge_duplicates: bool = True) -> str:
        """
        Build the final gitignore content.

        Args:
            merge_duplicates: Whether to remove duplicate patterns

        Returns:
            Complete gitignore file content
        """
        logger.info("Building gitignore file")

        all_lines = []
        seen_patterns = set()

        # Process all sections
        for section_name, section_content in self.sections:
            if merge_duplicates and section_name != "header":
                # Filter out duplicate patterns
                filtered_lines = []
                for line in section_content.split("\n"):
                    # Skip empty lines and comments for deduplication
                    stripped = line.strip()
                    if stripped and not stripped.startswith("#"):
                        if stripped not in seen_patterns:
                            seen_patterns.add(stripped)
                            filtered_lines.append(line)
                    else:
                        filtered_lines.append(line)

                if filtered_lines:
                    all_lines.append("\n".join(filtered_lines))
                    logger.debug(f"Added section {section_name} with {len(filtered_lines)} lines")
            else:
                all_lines.append(section_content)
                logger.debug(f"Added section {section_name} without deduplication")

        # Add custom rules section if we have any
        if self.custom_rules:
            custom_section = [
                "",
                "# === Custom Rules ===",
                "# Add your project-specific patterns here",
            ]

            for rule in self.custom_rules:
                # Check for duplicates in custom rules too
                if not merge_duplicates or rule.strip() not in seen_patterns:
                    custom_section.append(rule)
                    if merge_duplicates and rule.strip() and not rule.strip().startswith("#"):
                        seen_patterns.add(rule.strip())

            all_lines.append("\n".join(custom_section))
            logger.debug(f"Added {len(self.custom_rules)} custom rules")

        # Join all sections with double newlines
        result = "\n\n".join(all_lines)

        # Ensure file ends with newline
        if not result.endswith("\n"):
            result += "\n"

        logger.info(f"Built gitignore with {len(seen_patterns)} unique patterns")
        return result

    def merge_with_existing(self, existing_path: Path) -> str:
        """
        Merge with an existing gitignore file, preserving custom rules.

        Args:
            existing_path: Path to existing gitignore file

        Returns:
            Merged gitignore content
        """
        if not existing_path.exists():
            logger.debug(f"No existing file at {existing_path}")
            return self.build()

        logger.info(f"Merging with existing gitignore at {existing_path}")

        existing_content = existing_path.read_text()

        # Try to extract custom rules from existing file
        custom_rules = []
        in_custom_section = False

        for line in existing_content.split("\n"):
            if "=== Custom Rules ===" in line or "# Custom" in line:
                in_custom_section = True
                continue
            elif in_custom_section and line.strip().startswith("# ==="):
                # End of custom section
                break
            elif in_custom_section and line.strip():
                custom_rules.append(line)

        if custom_rules:
            logger.debug(f"Preserved {len(custom_rules)} custom rules from existing file")
            self.add_custom_rules(custom_rules)

        return self.build()


# üß∞üåçüîö
